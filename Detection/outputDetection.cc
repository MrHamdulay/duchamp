#include <iostream>
#include <sstream>
#include <fstream>
#include <iomanip>
#include <string>
#include <vector>
#include <stdio.h>
#include <param.hh>
#include <Detection/detection.hh>
#include <Cubes/cubes.hh>
#include <Utils/utils.hh>
#include <Detection/columns.hh>

using std::endl;
using std::setw; 
using std::setfill;
using std::setprecision;
 
using namespace Column;

void outputDetectionTextWCSHeader(std::ostream &stream, ColSet columns)
{
  /**
   * outputDetectionTextWCSHeader
   *  Prints to a stream the column headers to match the output generated by outputDetectionTextWCS
   */

  stream << setfill(' ');
  for(int i=0;i<columns.vec.size();i++) columns.vec[i].dash(stream);
  stream << endl;
  for(int i=0;i<columns.vec.size();i++) columns.vec[i].title(stream);
  stream << endl;
  for(int i=0;i<columns.vec.size();i++) columns.vec[i].units(stream);
  stream << endl;
  for(int i=0;i<columns.vec.size();i++) columns.vec[i].dash(stream);
  stream << endl;

}

void Detection::outputDetectionTextWCS(std::ostream &stream, ColSet columns)
{
  /**
   * outputDetectionTextWCS
   *  Prints to a stream the relevant details of a detected object,
   *  including the WCS parameters, which need to have been calculated.
   *  If they have not (given by the isWCS() function), then the 
   *  WCS-related outputs are left blank.
   */

  stream.setf(std::ios::fixed);  
  columns.vec[0].entry(stream,this->id);
  columns.vec[1].entry(stream,this->name);
  stream << setprecision(xyzPrec);
  columns.vec[2].entry(stream,this->xcentre + this->xSubOffset);
  columns.vec[3].entry(stream,this->ycentre + this->ySubOffset);
  columns.vec[4].entry(stream,this->zcentre + this->zSubOffset);
  if(this->flagWCS){
    columns.vec[5].entry(stream,this->raS);
    columns.vec[6].entry(stream,this->decS);
    stream << setprecision(velPrec);
    columns.vec[7].entry(stream,this->vel);
    stream << setprecision(wposPrec);
    columns.vec[8].entry(stream,this->raWidth);
    columns.vec[9].entry(stream,this->decWidth);
    stream << setprecision(velPrec);
    columns.vec[10].entry(stream,this->velWidth);
  }
  else for(int i=5;i<11;i++) columns.vec[i].blank(stream);
  stream << setprecision(fluxPrec);
  if(this->flagWCS) columns.vec[11].entry(stream,this->intFlux);
  else columns.vec[11].entry(stream,this->totalFlux);
  columns.vec[12].entry(stream,this->peakFlux);
  columns.vec[13].entry(stream,this->xmin + this->xSubOffset);
  columns.vec[14].entry(stream,this->xmax + this->xSubOffset);
  columns.vec[15].entry(stream,this->ymin + this->ySubOffset);
  columns.vec[16].entry(stream,this->ymax + this->ySubOffset);
  columns.vec[17].entry(stream,this->zmin + this->zSubOffset);
  columns.vec[18].entry(stream,this->zmax + this->zSubOffset);
  columns.vec[19].entry(stream,int(this->pix.size()));
  columns.vec[20].entry(stream,this->flagText);
  stream << endl;

}

void outputDetectionTextHeader(std::ostream &stream, ColSet columns)
{
  /**
   * outputDetectionTextHeader
   *  Prints to a stream the column headers to match the output generated by outputDetectionText
   */

  stream << setfill(' ');
  for(int i=0;i<columns.vec.size();i++) columns.vec[i].dash(stream);
  stream << endl;
  for(int i=0;i<columns.vec.size();i++) columns.vec[i].title(stream);
  stream << endl;
  for(int i=0;i<columns.vec.size();i++) columns.vec[i].units(stream);
  stream << endl;
  for(int i=0;i<columns.vec.size();i++) columns.vec[i].dash(stream);
  stream << endl;
}

void Detection::outputDetectionText(std::ostream &stream, ColSet columns, int idNumber)
{
  /**
   * outputDetectionText
   *  Print to a stream the relevant details of a detected object.
   *  This does not include any WCS parameters, only pixel positions & extent, 
   *    and flux info.
   *  Also prints a counter, provided as an input.
   */

  stream << setfill(' ');
  stream.setf(std::ios::fixed);  
  columns.vec[0].entry(stream,idNumber);
  stream << setprecision(xyzPrec);
  columns.vec[1].entry(stream,this->xcentre + this->xSubOffset);
  columns.vec[2].entry(stream,this->ycentre + this->ySubOffset);
  columns.vec[3].entry(stream,this->zcentre + this->zSubOffset);
  stream << setprecision(fluxPrec);
  columns.vec[4].entry(stream,this->totalFlux);
  columns.vec[5].entry(stream,this->peakFlux);
  columns.vec[6].entry(stream,this->xmin + this->xSubOffset);
  columns.vec[7].entry(stream,this->xmax + this->xSubOffset);
  columns.vec[8].entry(stream,this->ymin + this->ySubOffset);
  columns.vec[9].entry(stream,this->ymax + this->ySubOffset);
  columns.vec[10].entry(stream,this->zmin + this->zSubOffset);
  columns.vec[11].entry(stream,this->zmax + this->zSubOffset);
  columns.vec[12].entry(stream,int(this->pix.size()));
  stream<<endl;

}

string Detection::outputLabelWCS()
{

  std::stringstream ss;
  ss << "#" << setfill('0') << setw(3) << this->id << ": ";
  ss << this->name ;
  if(this->getFlagText()!="") 
    ss << " [" << this->getFlagText() << "]   ";
  else ss<< "   ";
  ss << setfill(' ');
  ss << this->raS << ", ";
  ss << this->decS;
  ss << setprecision(3);
  ss.setf(std::ios::fixed);
  ss << ", " << this->vel << " " << this->specUnits;

  return ss.str();


}


string Detection::outputLabelInfo()
{
  /**
   * outputLabelInfo
   *  Prints to a string the widths of the object (in position and velocity), 
   *  as well as the flux information.
   *  Assumes the WCS parameters of the object have been calculated.
   *  If they have not (given by the isWCS() function), then the WCS-related outputs 
   *  are left blank.
   *  Returns the string.
   */

  std::stringstream ss;
  ss.setf(std::ios::fixed);
  if(this->flagWCS){
    ss << setprecision(2);
    ss << "w_"          << this->lngtype  <<"="    << this->raWidth;
    ss << ", w_"        << this->lattype  <<"="    << this->decWidth;
    ss << setprecision(3);
    ss << ", w_Vel="    << this->velWidth << " " << this->specUnits;
    ss << ", F\\dint\\u=" << this->intFlux << " " << this->intFluxUnits;
    ss << ", F\\dpeak\\u=" << this->peakFlux << " " << this->fluxUnits;
  }
  else{ 
    ss << "#" << setfill('0') << setw(3) << this->id << ": ";
    ss << setprecision(3);
    ss << "F\\dtot\\u=" << this->totalFlux << this->fluxUnits;
    ss << ", F\\dpeak\\u=" << this->peakFlux << this->fluxUnits;
  }
  string output = ss.str();

  return output;
}


string Detection::outputLabelPix()
{
  /**
   * outputLabelPix
   *  Prints to a string the pixel centres and extents of a detected object.
   *  Returns the string.
   */

  std::stringstream ss;
  ss.setf(std::ios::fixed);
  // // This is the OLD code -- have improved the formatting below...
//   ss << this->pix.size() << " Voxels:  ";
//   ss << setprecision(1) << setfill(' ');
//   ss       <<setw(5)<< this->xcentre + this->xSubOffset;
//   ss <<" " <<setw(5)<< this->ycentre + this->ySubOffset;
//   ss <<" " <<setw(5)<< this->zcentre + this->zSubOffset;
//   ss <<" ["<<setw(3)<< this->xmin + this->xSubOffset   <<":"<< this->xmax + this->xSubOffset;
//   ss <<", "<<setw(3)<< this->ymin + this->ySubOffset   <<":"<< this->ymax + this->ySubOffset;
//   ss <<", "<<setw(3)<< this->zmin + this->zSubOffset   <<":"<< this->zmax + this->zSubOffset << "]";
  ss << "Centre: ";
  ss << setprecision(1) << setfill(' ');
  ss <<"("  << this->xcentre + this->xSubOffset;
  ss <<", " << this->ycentre + this->ySubOffset;
  ss <<", " << this->zcentre + this->zSubOffset << ")";
  ss <<", Size: " << this->pix.size() << " voxels,  ";
  ss <<"Range: ["<< this->xmin + this->xSubOffset <<":"<< this->xmax + this->xSubOffset;
  ss <<", "      << this->ymin + this->ySubOffset <<":"<< this->ymax + this->ySubOffset;
  ss <<", "      << this->zmin + this->zSubOffset <<":"<< this->zmax + this->zSubOffset << "]";
  
  return ss.str();
}


